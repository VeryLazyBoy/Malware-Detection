from model import MyModel
import pandas as pd
import torch
import numpy as np
import torch.nn as nn
from tqdm.auto import tqdm


class Tester():

    testSize = 6051
    featureSize = 102
    sequenceLength = 1000
    batchSize = 50
    def __init__(self, device):
        self.device = device

    def _load(self, filePath):
        checkpoint = torch.load(filePath)
        model = MyModel(device, checkpoint['inputSize'], checkpoint['gatedCnnOutputSize'], checkpoint['gatedCnnStride1'], checkpoint['gatedCnnStride2'], checkpoint['gatedCnnKernel1'], checkpoint['gatedCnnKernel2'], checkpoint['lstmLayer'], checkpoint['lstmHiddenSize'], checkpoint['fcOutputSize'], checkpoint['dropout'])
        model.load_state_dict(checkpoint['stateDict'])
        model.eval()

        if self.device.type == 'cpu':
            model.cpu()
        else:
            model.cuda(device=self.device)
        return model

    def loadModel(self, filePath):
        self.model = self._load(filePath)

    def test(self):
        with torch.no_grad():
            result = {}
            sigmoid = nn.Sigmoid()

            # Loads test input to allInputs
            allInputs = torch.empty(self.__class__.testSize, self.__class__.sequenceLength, self.__class__.featureSize)
            pbar = tqdm(total=allInputs.size(0), desc='Starting to load input data...')
            for i in range(self.__class__.testSize):
                inputs = np.load('test/{}.npy'.format(i))
                inputs = torch.from_numpy(inputs)

                padSize = list(inputs.shape)
                padSize[0] = self.__class__.sequenceLength - inputs.size(0)
                inputs = torch.cat([inputs, torch.zeros(*padSize)], dim=0)
                allInputs[i] = inputs
                pbar.update(1)
            pbar.close()

            # Computes probabilites in batches
            batch = list(range(0, self.__class__.testSize, self.__class__.batchSize)) + [self.__class__.testSize]
            pbar = tqdm(total=len(batch) - 1, desc='Starting to compute probabilities...')
            for i in range(len(batch) - 1):
                start = batch[i]
                end = batch[i + 1]
                indices = list(range(start, end))
                inputs = allInputs[indices]
                inputs = inputs.permute(0,2,1).to(self.device)
                outputs = self.model(inputs)
                outputs = sigmoid(outputs)

                for j in range(len(indices)):
                    result[indices[j]] = outputs[j].item()
                pbar.update(1)
            pbar.close()

            resultFrame = pd.DataFrame(list(result.items()), columns=['Id', 'Predicted'])
            resultFrame.to_csv('solution3.csv', index=False)


t = 1573200428
id = 0
device = torch.device('cuda:0' if torch.cuda.is_available() else 'cpu')
tester = Tester(device)
tester.loadModel('model/model_{}/model{}.pt'.format(t, id))
tester.test()


